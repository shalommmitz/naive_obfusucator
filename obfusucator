#!/usr/bin/env python3
"""
Word replacement script - reversible obfuscation of text files and filenames

Usage:
    python3 word_replacer.py /path/to/your/folder

Creates:
    your_folder_modified/
    your_folder_modified/mapping.yaml
    your_folder_unmodified/   (when running the reverse function)
"""

import sys
import os
import random
import yaml
import shutil
import filecmp
import difflib
from pathlib import Path
from typing import Dict, Set

# Small list of short, common English words for replacement
REPLACEMENT_POOL = [
    "cat", "dog", "fox", "bird", "tree", "sky", "moon", "star", "fish", "frog",
    "bear", "wolf", "deer", "lion", "hawk", "rain", "wind", "fire", "ice", "stone",
    "hill", "lake", "road", "gate", "door", "wall", "ship", "boat", "car", "bike",
    "hand", "foot", "head", "eye", "ear", "nose", "mouth", "hair", "wing", "tail",
    "nest", "cave", "den", "web", "leaf", "seed", "root", "wave", "cloud", "sand"
]

def get_all_words_to_replace() -> Set[str]:
    """Read words to replace from words.yaml in current directory"""
    yaml_path = Path("words.yaml")
    if not yaml_path.is_file():
        print("Error: words.yaml not found in current directory")
        sys.exit(1)

    with yaml_path.open("r", encoding="utf-8") as f:
        data = yaml.safe_load(f)

    if not isinstance(data, list):
        print("Error: words.yaml should contain a YAML list of strings")
        sys.exit(1)

    words = {w.strip() for w in data if w and isinstance(w, str) and w.strip()}
    print(f"Loaded {len(words)} words to replace")
    return words


def create_random_mapping(words: Set[str]) -> Dict[str, str]:
    """Create a random 1:1 mapping from original words → replacement words"""
    if len(words) > len(REPLACEMENT_POOL):
        print(f"Warning: Only {len(REPLACEMENT_POOL)} replacement words available, "
              f"but {len(words)} words requested → some words will share replacements")

    shuffled = REPLACEMENT_POOL[:]
    random.shuffle(shuffled)

    mapping = {}
    for orig in sorted(words):  # sort for reproducible order in case of ties
        repl = shuffled[len(mapping) % len(shuffled)]
        mapping[orig] = repl

    # Make sure we don't have accidental identity mappings (optional but cleaner)
    for orig, repl in list(mapping.items()):
        if orig.lower() == repl.lower():
            # swap with next one if possible
            items = list(mapping.items())
            i = items.index((orig, repl))
            if i + 1 < len(items):
                _, next_repl = items[i + 1]
                mapping[orig] = next_repl
                mapping[items[i + 1][0]] = repl

    return mapping


def replace_in_text(text: str, mapping: Dict[str, str], case_sensitive: bool = False) -> str:
    """Replace whole words according to mapping"""
    if not mapping:
        return text

    # Very naive whole-word replacement (can be improved with regex word boundaries)
    result = text
    for old, new in mapping.items():
        if case_sensitive:
            result = result.replace(old, new)
        else:
            # Case insensitive replace while preserving case is trickier
            # Here we do simple replace — for better quality consider regex + case matching
            result = result.replace(old.lower(), new.lower())
            result = result.replace(old.upper(), new.upper())
            result = result.replace(old.title(), new.title())

    return result


def process_folder(input_dir: str, mode: str = "obfuscate") -> None:
    input_path = Path(input_dir).resolve()
    if not input_path.is_dir():
        print(f"Error: {input_path} is not a directory")
        sys.exit(1)

    base_name = input_path.name
    if base_name.endswith("_modified"):
        base_name = base_name[:-len("_modified")]
    output_suffix = "_modified" if mode == "obfuscate" else "_unmodified"
    output_dir = input_path.with_name(base_name + output_suffix)

    if mode == "obfuscate":
        mapping_path = output_dir / "mapping.yaml" 
    else:
        mapping_path = (input_path.parent / (base_name + "_modified") / "mapping.yaml")
    print("mapping_path:", mapping_path)

    if mode == "obfuscate":
        # ── Obfuscation ───────────────────────────────────────────────
        if output_dir.exists():
            print(f"Removing existing folder: {output_dir}")
            shutil.rmtree(output_dir)

        print(f"Copying folder → {output_dir}")
        shutil.copytree(input_path, output_dir)

        words_to_replace = get_all_words_to_replace()
        if not words_to_replace:
            print("No words to replace → copy only")
            return

        mapping = create_random_mapping(words_to_replace)

        # Save mapping
        with (output_dir / "mapping.yaml").open("w", encoding="utf-8") as f:
            yaml.safe_dump(mapping, f, sort_keys=True, allow_unicode=True)
        print(f"Created mapping with {len(mapping)} entries")

        # Process files recursively
        renamed_count = 0
        modified_count = 0

        for root, dirs, files in os.walk(output_dir, topdown=False):
            # Rename files (bottom-up)
            for fname in files:
                old_path = Path(root) / fname
                new_name = replace_in_text(fname, mapping)
                if new_name != fname:
                    new_path = Path(root) / new_name
                    old_path.rename(new_path)
                    renamed_count += 1

            # Rename directories (bottom-up)
            for i, dname in enumerate(dirs[:]):  # copy because we modify list
                old_path = Path(root) / dname
                new_name = replace_in_text(dname, mapping)
                if new_name != dname:
                    new_path = Path(root) / new_name
                    old_path.rename(new_path)
                    # Update dirs list so walk continues correctly
                    dirs[i] = new_name

        # Now replace contents
        for root, _, files in os.walk(output_dir):
            for fname in files:
                if fname == "mapping.yaml":
                    continue
                path = Path(root) / fname
                try:
                    orig = path.read_text(encoding="utf-8", errors="replace")
                    modified = replace_in_text(orig, mapping)
                    if modified != orig:
                        path.write_text(modified, encoding="utf-8")
                        modified_count += 1
                except UnicodeDecodeError:
                    # Skip binary files
                    continue
                except Exception as e:
                    print(f"Skipping {path}: {e}")

        print(f"Done obfuscating.")
        print(f"  Renamed files/directories : {renamed_count}")
        print(f"  Modified text files       : {modified_count}")
        print(f"Mapping saved to: {output_dir}/mapping.yaml")

    else:
        # ── De-obfuscation ────────────────────────────────────────────
        if not mapping_path.is_file():
            print(f"Error: mapping.yaml not found at {mapping_path}")
            sys.exit(1)

        with mapping_path.open("r", encoding="utf-8") as f:
            mapping = yaml.safe_load(f)

        # Create reverse mapping
        reverse_mapping = {v: k for k, v in mapping.items()}

        if output_dir.exists():
            shutil.rmtree(output_dir)

        print(f"Creating clean copy → {output_dir}")
        shutil.copytree(input_path, output_dir)

        renamed_count = 0
        restored_count = 0

        for root, dirs, files in os.walk(output_dir, topdown=False):
            for fname in files:
                old_path = Path(root) / fname
                new_name = replace_in_text(fname, reverse_mapping)
                if new_name != fname:
                    new_path = Path(root) / new_name
                    old_path.rename(new_path)
                    renamed_count += 1

            for i, dname in enumerate(dirs[:]):
                old_path = Path(root) / dname
                new_name = replace_in_text(dname, reverse_mapping)
                if new_name != dname:
                    new_path = Path(root) / new_name
                    old_path.rename(new_path)
                    dirs[i] = new_name

        for root, _, files in os.walk(output_dir):
            for fname in files:
                if fname == "mapping.yaml":
                    continue
                path = Path(root) / fname
                try:
                    obfuscated = path.read_text(encoding="utf-8", errors="replace")
                    original = replace_in_text(obfuscated, reverse_mapping)
                    if original != obfuscated:
                        path.write_text(original, encoding="utf-8")
                        restored_count += 1
                except:
                    continue

        print(f"Reverse operation completed.")
        print(f"  Restored filenames : {renamed_count}")
        print(f"  Restored contents  : {restored_count}")


def compare_folders(original: str, restored: str):
    """Simple recursive comparison with summary and diff on first mismatch"""
    original = Path(original).resolve()
    restored = Path(restored).resolve()

    print(f"\nComparing:\n  Original : {original}\n  Restored : {restored}\n")

    diff_found = False
    total_files = 0
    matching = 0
    different = 0
    only_in_orig = 0
    only_in_rest = 0

    dcmp = filecmp.dircmp(original, restored, ignore=[])  # no ignore

    def compare_dirs(left: Path, right: Path, rel: str = ""):
        nonlocal diff_found, total_files, matching, different, only_in_orig, only_in_rest

        cmp = filecmp.dircmp(left, right)

        # Files only in left / right
        for f in cmp.left_only:
            only_in_orig += 1
            print(f"Only in original: {rel}/{f}")
        for f in cmp.right_only:
            only_in_rest += 1
            print(f"Only in restored: {rel}/{f}")

        # Common files
        for fname in cmp.common_files:
            total_files += 1
            p1 = left / fname
            p2 = right / fname

            if filecmp.cmp(p1, p2, shallow=False):
                matching += 1
            else:
                different += 1
                if not diff_found:
                    diff_found = True
                    print(f"\nFirst difference found in:\n  {p1}\n  {p2}\n")
                    try:
                        lines1 = p1.read_text(encoding="utf-8").splitlines()
                        lines2 = p2.read_text(encoding="utf-8").splitlines()
                        diff = difflib.unified_diff(
                            lines1, lines2,
                            fromfile=str(p1.relative_to(original)),
                            tofile=str(p2.relative_to(restored)),
                            lineterm=""
                        )
                        print("\n".join(diff))
                        print("\n" + "─"*70)
                    except:
                        print("(binary or non-UTF-8 file — no text diff shown)")

        # Recurse subdirectories
        for sub in cmp.common_dirs:
            compare_dirs(left / sub, right / sub, f"{rel}/{sub}" if rel else sub)

    compare_dirs(original, restored)

    print("\nSummary:")
    print(f"  Total compared files : {total_files}")
    print(f"  Identical            : {matching}")
    print(f"  Different            : {different}")
    print(f"  Only in original     : {only_in_orig}")
    print(f"  Only in restored     : {only_in_rest}")

    if different == 0 and only_in_orig == 0 and only_in_rest == 0:
        print("\n→ Folders are IDENTICAL ✓")
    else:
        print("\n→ Folders DIFFER ✓")


def main():
    if len(sys.argv) != 2:
        print("Usage: python3 word_replacer.py <folder_path>")
        sys.exit(1)

    folder = sys.argv[1]

    # Obfuscate
    process_folder(folder, mode="obfuscate")

    modified_folder = Path(folder).resolve().with_name(
        Path(folder).name + "_modified"
    )

    # De-obfuscate
    process_folder(str(modified_folder), mode="deobfuscate")

    unmodified_folder = Path(folder).resolve().with_name(
        Path(folder).name + "_unmodified"
    )

    # Compare
    compare_folders(folder, str(unmodified_folder))


if __name__ == "__main__":
    main()
